#!/usr/bin/python

print "//-----------------------------------------------------------------------------"
print "//"
print "// Copyright (C) 2018 Arend Lammertink"
print "//"
print "// This program is free software; you can redistribute it and/or modify it"
print "// under the terms of the GNU General Public License as published by the Free"
print "// Software Foundation, version 3."
print "//"
print "// This program is distributed in the hope that it will be useful, but WITHOUT"
print "// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or"
print "// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for"
print "// more details."
print "//"
print "// You should have received a copy of the GNU Lesser General Public License"
print "// along with this program. If not, see <http://www.gnu.org/licenses/>."
print "//-----------------------------------------------------------------------------"
print
print"//-----------------------------------------------------------------------------"
print"// 2D specialization for integers by casting to Fix16, generated by script."
print"//-----------------------------------------------------------------------------"
print

print 
print "#ifndef _interpol2d_spec_h"
print "#define _interpol2d_spec_h"
print 

## TODO: check if the fix16_lerp routines may be faster.


def getCast( from_tp, to_tp ):
    head = ""
    tail = ""

    if from_tp == to_tp:
      return head, tail

    head = "static_cast<"+to_tp+">("
    tail = ")"

    if to_tp == "Fix16":
        # uint16_t must be casted to float before it can be casted to Fix16
        if from_tp == "uint16_t":
          head += "static_cast<float>("
          tail += ")"
        elif from_tp == "uint8_t" or from_tp == "int8_t":
          head += "static_cast<int16_t>("
          tail += ")"

    if from_tp == "Fix16":
        # uint16_t must be casted to float before it can be casted to Fix16
        if to_tp == "uint16_t":
          head += "static_cast<float>("
          tail += ")"
        elif to_tp == "uint8_t" or to_tp == "int8_t":
          head += "static_cast<int16_t>("
          tail += ")"

    return head, tail



for X in ["int8_t", "uint8_t", "int16_t", "uint16_t", "Fix16"]:
  for Y in ["int8_t", "uint8_t", "int16_t", "uint16_t", "Fix16", "float", "double"]:

    if X == "Fix16" and Y == "Fix16":
      break  # no casting exercise required, so no specialisation either.

    interpol_tp = Y
    if interpol_tp in ["int8_t", "uint8_t", "int16_t", "uint16_t"]:
      interpol_tp = "Fix16"


    print"template<>"
    print"inline", Y, "interpolate(", X, "x1,", X, "x2,"
    print"                           ", X,"x_1,", X, "x_2,", X,"x_3,", X, "x_4,"
    print"                           ", Y, "y_1,", Y, "y_2,",  Y, "y_3,", Y, "y_4 )"
    print"{"


    rhead,rtail = getCast(interpol_tp, Y)

    print"#ifdef DEBUG"
    print"  " + interpol_tp + " retval = ("
    print"#else"
    print"  return " + rhead
    print"#endif"


    prcx,pocx = getCast(X,interpol_tp)
    prcy,pocy = getCast(Y,interpol_tp)
    
    print"                  interpolate( " + prcx + "x1"  + pocx + ","
    print"                               " + prcx + "x2"  + pocx + ","
    print"                               " + prcx + "x_1" + pocx + ","
    print"                               " + prcx + "x_2" + pocx + ","
    print"                               " + prcx + "x_3" + pocx + ","
    print"                               " + prcx + "x_4" + pocx + ","
    print"                               " + prcy + "y_1" + pocy + ","
    print"                               " + prcy + "y_2" + pocy + ","
    print"                               " + prcy + "y_3" + pocy + ","
    print"                               " + prcy + "y_4" + pocy + " )"


    print"#ifndef DEBUG"
    print"                             " + rtail +";"
    print"#else"
    print"  return " + rhead + "retval" + rtail +";"
    print"#endif"

    print"}"
    print
    print

print "#endif"
